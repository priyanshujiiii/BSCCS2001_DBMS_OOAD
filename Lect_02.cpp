//Understand why software is complex
//Study the elements of Compplexity


//>> Defining software complexity
//>> Four elemnts of complexity
//>>>> The Complxity of the problem domain.
//>>>> The difficulty of managing the development process
//>>>> The Flexibility Possible through software
//>>>> The Probles of characterizing the behavior Discrete Systems.


//>> Personal or limited-use Software
//>> Industrial-Strengh Software

//>> Limited set of behaviours
//>> Not very complex
//>> Specified , constructed , maintained , and used by the same person or a small group.
//>>>> Amateur programmer , or
//>>>> Professional developer woking in isolation
//>> Tend to have short life span 
//>> Can be thrown away and replaced with entirely new software rather
//    attempt to reuse them , repair them, or extend their functionality
//>> Generally more tedious then difficult to develop 
//>> Techniques to develop them is of little interest here

//>> Exhbit a very rich set of behaviors - reactive systems that drive or are
//   driven by events in the physical world.
//>> Works with scarce resources - time, space, power,.....
//>> Maintain the intergrity of millions of record while allowing 
//   concurrent updates and quries - airline booking 
//>> Commands and contols of real-world entites- routing of air or
//   railway traffic
//>> Depended by many users over time on proper functioning 
//>> usually based onframeworks that simplify the creation of
     domain-specific applications

// Complexity of industrial strength strength software systems of the 
// human intellectual capacity


// Software is inherently complex
//>> The Complity of the problem domain.
//>> The difficulty of managing the development process
//>> The Flexibility possible through software
//>> The problems of characterizing the behaviour of Discrete Systems

// The complexity of the problem domain
//>> Domains are difficult to understand. For exampele:
//>>>> Electronic system of a multi-engine aircraft
//>>>> Merchant shipping
//>>>> Online Trading and reconciliation
//>> Functional Requirments are 
//>>>> Complex to master 
//>>>> Often are competing , even contradictory
//>> Non- Functional Requirements( usability , perfomanc,
cost, survivability, and reliabiliy) are 
//>>>> often implicit
//>>>> difficult to justify in budget
